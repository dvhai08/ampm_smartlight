/******************************************************************************
 *
 * (c) Copyright 2010-2013, Freescale Semiconductor Inc.
 *
 * ALL RIGHTS RESERVED. FREESCALE SEMICONDUCTOR CONFIDENTIAL PROPRIETARY. 
 *  
 ***************************************************************************//*!
 *
 * @file      METERLIB1PH.c
 *
 * @author    R55013
 *
 * @version   1.0.8.0
 *
 * @date      Mar-08-2014
 *
 * @brief     Source file containing routines with implementation metering 
 *            specific calculations and algorithms.
 * 
 ******************************************************************************/ 
#include "fraclib.h"
#include "meterlib.h"
   
/******************************************************************************
 * Inline function definition                                                 *
 ******************************************************************************/
static inline int CalcEnergy (tENERGY_DATA *p, Frac24 u, Frac24 i, Frac32 *pCnt, 
                              Frac64 outRes)
{
  register Frac64 energy, tmp, val;
  /* smooth energy measurements                                               */
  energy = LL_add(LL_iir_1ord(LL_mul_ll(i,u),&p->xIIR,&p->yIIR,p->cofIIR),p->offset);
          
  /* process energy display value                                             */
  tmp = LL_add(p->dispRem,energy);
  if      (tmp >=  p->dispRes) { p->dispRem=LL_sub(tmp,p->dispRes); (*pCnt)++; } 
  else if (tmp <= -p->dispRes) { p->dispRem=LL_add(tmp,p->dispRes); /*(*pCnt)--; */} 
  else                         { p->dispRem=tmp;                               } 
  
  /* process and generate pulse outputs                                       */
  tmp = LL_add(p->pulsRem,energy);
  if      (tmp >=  outRes) { val=LL_abs(p->pulsRem=LL_sub(tmp,outRes)); p->pulsOut^=1; }
  else if (tmp <= -outRes) { val=LL_abs(p->pulsRem=LL_add(tmp,outRes)); p->pulsOut^=1; }
  else                     { val=FRAC64(-1.0); p->pulsRem = tmp;                       }   

  /* calculate fine pulse delay to be generated by the Timer                  */
  if (val >= 0ll) { tmp=LL_abs(energy); p->pulsDly=S_div_llll(LL_sub(tmp,val),tmp); } 
  else            { p->pulsDly=FRAC16(-1.0);                                        } 
  
  /* return rough pulse output state                                          */
  return p->pulsOut;
}

#if defined(__ICCARM__) || defined(__GNUC__)
  static inline unsigned int GetInterruptMask (void)
  { 
    register unsigned int mask;
    __asm volatile("MRS %[Rd],PRIMASK":[Rd]"=r"(mask));
    return mask;
  }
#elif defined(__CC_ARM)
  static inline unsigned int GetInterruptMask (void)
  { 
    register unsigned int mask;
    __asm volatile("MRS mask,PRIMASK");
    return mask;
  }
#endif 

#if defined(__ICCARM__) || defined(__GNUC__)
  static inline void SetInterruptMask (register unsigned int mask)
  {
    __asm volatile("MSR PRIMASK,%[Rs]":[Rs]"+r"(mask));
  }
#elif defined(__CC_ARM)
  static inline void SetInterruptMask (register unsigned int mask)
  {
    __asm volatile("MSR PRIMASK,mask");
  }
#endif 

/*************************************************************************//*!
 *
 * @brief   Remove DC bias from phase voltage and phase current samples.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   u1Q     Phase 1 instantaneous voltage sample in 24-bit data format.
 * @param   i1Q     Phase 1 instantaneous current sample in 24-bit data format.
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. 
 *
 ****************************************************************************/  
void METERLIB1PH_RemoveDcBias (tMETERLIB1PH_DATA *p, Frac24 u1Q, Frac24 i1Q)
{   
  register Frac64 tmp;
  
  if (p->sens == 1) /* current sensor with proportional output characteristic */
  {
    /* Remove DC bias from phase voltage and phase current measurements       */
    LL_iir_1ord_ll (u1Q,&p->uDcb[1].xIIR,&p->uDcb[1].yIIR,p->bias.cofIIR);
    LL_iir_1ord_ll (i1Q,&p->iDcb[1].xIIR,&p->iDcb[1].yIIR,p->bias.cofIIR);   
  } 
  else              /* current sensor with derivative output characteristic   */
  {
    /* Remove DC bias from phase voltage measurements                         */
    tmp = LL_iir_1ord_ll (u1Q,&p->uDcb[0].xIIR,&p->uDcb[0].yIIR,p->bias.cofIIR);
    LL_iir_1ord_ll (L_extract_hi(tmp),&p->uDcb[1].xIIR,&p->uDcb[1].yIIR,p->bias.cofIIR);
  
    /* Remove DC bias from phase current measurements and integrate           */
    tmp = LL_iir_1ord_ll (i1Q,&p->iDcb[0].xIIR,&p->iDcb[0].yIIR,p->bias.cofIIR);
    tmp = LL_iir_1ord_ll (L_extract_hi(tmp),&p->intd.xIIR,&p->intd.yIIR,p->intg.cofIIR);
    LL_iir_1ord_ll (L_extract_hi(tmp),&p->iDcb[1].xIIR,&p->iDcb[1].yIIR,p->bias.cofIIR);
  }
}

/*************************************************************************//*!
 *
 * @brief   Recalculate active energy using new voltage and current samples.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   pCnt    Pointer to LCD counter representing active energy.
 * @param   outRes  Resolution of pulse output (calculated by KWH_PULS_NUM())
 * @return  Function returns rough pulse output state.
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. Typical calling frequency depends on the
 *          possibilities of the analogue front-end. This frequency must be 
 *          used for calculation IIR high-pass and FIR filter paremeters.
 *          This function must be called prior METERLIB1PH_CalcVarHours and 
 *          METERLIB1PH_CalcAuxiliary functions.
 *
 ****************************************************************************/  
int METERLIB1PH_CalcWattHours (tMETERLIB1PH_DATA *p, Frac32 *pCnt, Frac64 outRes, Frac32 Correct)
{   
  register Frac32 tmp32_1, tmp32_2;
  
  tmp32_1 = L_mul(Correct,L_extract_hi(p->uDcb[1].yIIR));
  //tmp32_1 = L_extract_hi(p->uDcb[1].yIIR);
  tmp32_2 = L_extract_hi(p->iDcb[1].yIIR); 

  /* active energy calculation and pulse state output                         */
  return CalcEnergy (&p->Wh, tmp32_1, tmp32_2, pCnt, outRes);  
}

/*************************************************************************//*!
 *
 * @brief   Recalculate reactive energy.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   pCnt    Pointer to LCD counter representing reactive energy.
 * @param   outRes  Resolution of pulse output (calculated by KVARH_PULS_NUM())
 * @return  Function returns rough pulse output state.
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. Typical calling frequency is several times 
 *          lower than calling frequency of the METERLIB1PH_CalcWattHours function. 
 *          The frequency of this function calls must be used for calculation FIR 
 *          filters parameters. Function disables and enables interrupts during
 *          execution.
 *
 ****************************************************************************/  
int METERLIB1PH_CalcVarHours (tMETERLIB1PH_DATA *p, Frac32 *pCnt, Frac64 outRes, Frac32 Correct)
{
  register Frac32 tmp32_1, tmp32_2;
  
  tmp32_1 = L_mul(Correct,L_extract_hi(p->uDcb[1].yIIR));
  //tmp32_1 = L_extract_hi(p->uDcb[1].yIIR);
  tmp32_2 = L_extract_hi(p->iDcb[1].yIIR); 
    
  /* calculate 90 degree instantaneous voltage phase shift and postprocess    */
  /* instantaneous current measurement to compensate for Hilbert FIR filter   */
  /* group delay                                                              */ 
  p->phSh.yFIR1 =  LL_fir_ll(tmp32_1,p->phSh.xFIR1,p->hilb.cofFIR1,p->hilb.lenFIR1);
  p->phSh.yFIR2 = -L_fir_ls (tmp32_2,p->phSh.xFIR2,p->hilb.cofFIR2,p->hilb.lenFIR2);
    
  /* reactive energy calculation and pulse state output                       */
  return CalcEnergy (&p->VARh, L_extract_hi(p->phSh.yFIR1), p->phSh.yFIR2, pCnt, 
                     outRes);
}

/*************************************************************************//*!
 *
 * @brief   Recalculate auxiliary variables; IRMS, URMS, P, Q and S.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. Typical calling frequency is several times 
 *          lower than calling frequency of the METERLIB1PH_CalcWattHours function. 
 *          The frequency of this function calls must be used for calculation all 
 *          IIR low pass filter parameters. Function disables and enables 
 *          interrupts during execution.
 *
 ****************************************************************************/
void METERLIB1PH_CalcAuxiliary (tMETERLIB1PH_DATA *p)
{
  register Frac32 tmp32_1, tmp32_2, tmp32_3, tmp32_4;
  register Frac64 tmp64_1;
  register unsigned int mask;
  
  /* disable interrupt and load variables                                     */
  mask = GetInterruptMask(); 
  __asm volatile ("CPSID i"); /* disable interrupts to keep data consistancy  */
  tmp32_1=p->iDcb[1].yIIR>>24; tmp32_2=p->uDcb[1].yIIR>>24;
  tmp32_3=p->phSh.yFIR2<<8; tmp32_4=p->phSh.yFIR1>>24; 
  SetInterruptMask (mask);    /* re-enable interrupts                         */
    
  /* Active power calculation                                                 */
  tmp64_1 = LL_mul_ll(tmp32_1,tmp32_2);
  tmp64_1 = LL_add(LL_iir_1ord (tmp64_1,&p->PAve.xIIR1,&p->PAve.yIIR1,p->aver.cofIIR1),
                   (p->Wh.offset<<16));   
  LL_iir_1ord_ll(L_extract_hi(tmp64_1),&p->PAve.xIIR2,&p->PAve.yIIR2,p->aver.cofIIR2);
    
  /* Reactive power calculation                                               */
  tmp64_1 = LL_mul_ll(tmp32_3,tmp32_4); 
  tmp64_1 = LL_add(LL_iir_1ord (tmp64_1,&p->QAve.xIIR1,&p->QAve.yIIR1,p->aver.cofIIR1),
                   (p->VARh.offset<<16));   
  LL_iir_1ord_ll(L_extract_hi(tmp64_1),&p->QAve.xIIR2,&p->QAve.yIIR2,p->aver.cofIIR2);
    
  /* Voltage RMS calculation - direct RMS converter                           */
  tmp64_1 = LL_mul_ll   (tmp32_2,tmp32_2);
  tmp64_1 = LL_iir_1ord (tmp64_1,&p->uRms.xIIR1,&p->uRms.yIIR1,p->aver.cofIIR1);
  LL_iir_1ord_ll(L_sqr_ll(tmp64_1),&p->uRms.xIIR2,&p->uRms.yIIR2,p->aver.cofIIR2); 
  
  /* Current RMS calculation                                                  */
  if (p->sens == 1) /* current sensor with proportional output characteristic */
  {
    /* Current RMS calculation - direct RMS converter                         */
    tmp64_1 = LL_mul_ll   (tmp32_1,tmp32_1);
    tmp64_1 = LL_iir_1ord (tmp64_1,&p->iRms.xIIR1,&p->iRms.yIIR1,p->aver.cofIIR1);         
    LL_iir_1ord_ll(L_sqr_ll(tmp64_1),&p->iRms.xIIR2,&p->iRms.yIIR2,p->aver.cofIIR2);
  } 
  else              /* current sensor with derivative output characteristic   */ 
  {
    /* Current RMS calculation from power triangle                            */
    tmp32_1 = L_extract_hi(p->PAve.yIIR2); tmp32_2 = L_extract_hi(p->QAve.yIIR2);
    tmp32_3 = L_sqr_ll(LL_mac_ll(LL_mul_ll(tmp32_1, tmp32_1), tmp32_2, tmp32_2));
    tmp32_4 = L_div(tmp32_3,L_extract_hi(p->uRms.yIIR2));
    LL_iir_1ord_ll(tmp32_4,&p->iRms.xIIR2,&p->iRms.yIIR2,p->aver.cofIIR2);    
  }
}

/*************************************************************************//*
 * @brief   Returns auxiliary variables: IRMS, URMS, P, Q and S.
 *
 * @param   p         Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   urms      Pointer to RMS value of phase voltage [U]
 * @param   irms      Pointer to RMS value of phase current calculated using Explicit 
 *                    RMS Estimator algorithm [A]
 * @param   w         Pointer to active power [W]
 * @param   var       Pointer to reactive power [VAr]
 * @param   va        Pointer to apparent power [VA]
 * @param   umax      Pointer to phase voltage circuit scaling (maximal peak voltage) [V]
 * @param   imax      Pointer to phase current circuit scaling (maximal peak current) [I]
 *
 * @remarks Implemented in C-language. Function disables interrupts prior 
 *          execution. Interrupts are re-enabled after function execution.
 *
 ****************************************************************************/
void METERLIB1PH_ReadResults (tMETERLIB1PH_DATA *p, double *urms, double *irms, 
                           double *w, double *var, double *va, double *umax, 
                           double *imax, Frac32 uGain, Frac32 iGain , Frac32 pGain)
{ 
  register Frac32 tmp_1, tmp_2, tmp_3, tmp_4;
  register unsigned int mask;
  Frac32 tmp;
  Frac64 Qs,Ps;
  /* disable interrupt and load variables                                     */
  mask = GetInterruptMask(); 
  __asm volatile ("CPSID i"); /* disable interrupts to keep data consistancy  */
  tmp_1 = L_extract_hi(p->uRms.yIIR2); tmp_2 = L_extract_hi(p->iRms.yIIR2);
  tmp_3 = L_extract_hi(p->PAve.yIIR2); tmp_4 = L_extract_hi(p->QAve.yIIR2);
  SetInterruptMask (mask);    /* re-enable interrupts                         */
   
  /* sensitivity threshold logic - clears powers and RMS current if values    */
  /* are below sensitivity threshold                                          */
  if ((tmp_3 < p->thrd) && (tmp_3 > -p->thrd)) { tmp_3 = 0l; }
  if ((tmp_4 < p->thrd) && (tmp_4 > -p->thrd)) { tmp_4 = 0l; }
  if ((tmp_3 ==     0l) && (tmp_4 ==      0l)) { tmp_2 = 0l; }
  
  /* convert fractional quantities to double precision format                 */
  tmp_1=L_mul(tmp_1,uGain);
  *urms = F32TODBL(tmp_1)*p->umax;       
  tmp_2=L_mul(tmp_2,iGain);
  *irms = F32TODBL(tmp_2)*p->imax;
	
	tmp = L_mul(uGain,iGain);
  tmp_3=L_mul(tmp_3,tmp);
  *w    = F32TODBL(tmp_3)*(p->umax)*(p->imax); 
  tmp_4=L_mul(tmp_4,tmp);
  *var  = F32TODBL(tmp_4)*(p->imax)*(p->umax);
  //*va   = (*urms)*(*irms);
  Ps= FRACLIB_FFMUL32(tmp_3,tmp_3);
  Qs= FRACLIB_FFMUL32(tmp_4,tmp_4);
  tmp=L_sqr_ll(Ps+Qs);
  *va= F32TODBL(tmp)*(p->imax)*(p->umax);
  *umax = p->umax;
  *imax = p->imax;  
}
/******************************************************************************
 * end of module                                                              *
 ******************************************************************************/