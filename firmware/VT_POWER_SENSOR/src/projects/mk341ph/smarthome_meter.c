#include "smarthome_meter.h"
#if defined(__ICCARM__) || defined(__GNUC__)
  static inline unsigned int GetInterruptMask (void)
  { 
    register unsigned int mask;
    __asm volatile("MRS %[Rd],PRIMASK":[Rd]"=r"(mask));
    return mask;
  }
#elif defined(__CC_ARM)
  static inline unsigned int GetInterruptMask (void)
  { 
    register unsigned int mask;
    __asm volatile("MRS mask,PRIMASK");
    return mask;
  }
#endif 

#if defined(__ICCARM__) || defined(__GNUC__)
  static inline void SetInterruptMask (register unsigned int mask)
  {
    __asm volatile("MSR PRIMASK,%[Rs]":[Rs]"+r"(mask));
  }
#elif defined(__CC_ARM)
  static inline void SetInterruptMask (register unsigned int mask)
  {
    __asm volatile("MSR PRIMASK,mask");
  }
#endif 
/******************************************************************************
 * Inline function definition                                                 *
 ******************************************************************************/
static inline int CalcEnergy (tENERGY_DATA *p, Frac24 u, Frac24 i, Frac32 *pCnt, 
                              Frac64 outRes)
{
  register Frac64 energy, tmp, val;
  /* smooth energy measurements                                               */
  energy = LL_add(LL_iir_1ord(LL_mul_ll(i,u),&p->xIIR,&p->yIIR,p->cofIIR),p->offset);
          
  /* process energy display value                                             */
  tmp = LL_add(p->dispRem,energy);
  if      (tmp >=  p->dispRes) 
	{
		p->dispRem=LL_sub(tmp,p->dispRes);
		(*pCnt)++;
	} 
  else if (tmp <= -p->dispRes)
	{
		p->dispRem=LL_add(tmp,p->dispRes); /*(*pCnt)--; */
//		(*pCnt)++;
	} 
  else                         
	{
		p->dispRem=tmp;
	} 
  
  /* process and generate pulse outputs                                       */
  tmp = LL_add(p->pulsRem,energy);
  if      (tmp >=  outRes) { val=LL_abs(p->pulsRem=LL_sub(tmp,outRes)); p->pulsOut^=1; }
  else if (tmp <= -outRes) { val=LL_abs(p->pulsRem=LL_add(tmp,outRes)); p->pulsOut^=1; }
  else                     { val=FRAC64(-1.0); p->pulsRem = tmp;                       }   

  /* calculate fine pulse delay to be generated by the Timer                  */
  if (val >= 0ll) { tmp=LL_abs(energy); p->pulsDly=S_div_llll(LL_sub(tmp,val),tmp); } 
  else            { p->pulsDly=FRAC16(-1.0);                                        } 
  
  /* return rough pulse output state                                          */
  return p->pulsOut;
}

/*************************************************************************//*!
 *
 * @brief   Remove DC bias from phase voltage and phase current samples.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   u1Q     Phase 1 instantaneous voltage sample in 24-bit data format.
 * @param   i1Q     Phase 1 instantaneous current sample in 24-bit data format.
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. 
 *
 ****************************************************************************/  
void SMARTHOME_RemoveDcBias (tSMARTHOME_DATA *p, Frac24 uQ, Frac24 *iQ)
{ 
	int i;
	/* current sensor with proportional output characteristic */
	/* Remove DC bias from phase voltage and phase current measurements       */
	LL_iir_1ord_ll (uQ,&p->uDcb[1].xIIR,&p->uDcb[1].yIIR,p->bias.cofIIR);
	for (i=0;i<NUM_CHAN;i++)
	{
		LL_iir_1ord_ll (iQ[i],&p->iDcb[i][1].xIIR,&p->iDcb[i][1].yIIR,p->bias.cofIIR);	
	}
}

/*************************************************************************//*!
 *
 * @brief   Recalculate active energy using new voltage and current samples.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   pCnt    Pointer to LCD counter representing active energy.
 * @param   outRes  Resolution of pulse output (calculated by KWH_PULS_NUM())
 * @return  Function returns rough pulse output state.
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. Typical calling frequency depends on the
 *          possibilities of the analogue front-end. This frequency must be 
 *          used for calculation IIR high-pass and FIR filter paremeters.
 *          This function must be called prior METERLIB1PH_CalcVarHours and 
 *          METERLIB1PH_CalcAuxiliary functions.
 *
 ****************************************************************************/  
int SMARTHOME_CalcWattHours (tSMARTHOME_DATA *p, Frac32 *pCnt, Frac64 *outRes)
{
	int index=0;
	register Frac32 tmp32_1, tmp32_2;
	for (index=0;index<NUM_CHAN;index++)
	{
		tmp32_1 = L_extract_hi(p->uDcb[1].yIIR);
		tmp32_2 = L_extract_hi(p->iDcb[index][1].yIIR); 
		/* active energy calculation and pulse state output                         */
		CalcEnergy (&p->Wh[index], tmp32_1, tmp32_2, pCnt+index, outRes[index]);  	
	}
	return 0;
}
/*************************************************************************//*!
 *
 * @brief   Recalculate reactive energy.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   pCnt    Pointer to LCD counter representing reactive energy.
 * @param   outRes  Resolution of pulse output (calculated by KVARH_PULS_NUM())
 * @return  Function returns rough pulse output state.
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. Typical calling frequency is several times 
 *          lower than calling frequency of the METERLIB1PH_CalcWattHours function. 
 *          The frequency of this function calls must be used for calculation FIR 
 *          filters parameters. Function disables and enables interrupts during
 *          execution.
 *
 ****************************************************************************/  
int SMARTHOME_CalcVarHours (tSMARTHOME_DATA *p, Frac32 *pCnt, Frac64 *outRes)
{
	int index=0;
  register Frac32 tmp32_1, tmp32_2;
  for (index=0;index<NUM_CHAN;index++)
	{
		tmp32_1 = L_extract_hi(p->uDcb[1].yIIR);
		tmp32_2 = L_extract_hi(p->iDcb[index][1].yIIR); 
		/* calculate 90 degree instantaneous voltage phase shift and postprocess    */
		/* instantaneous current measurement to compensate for Hilbert FIR filter   */
		/* group delay                                                              */ 
		p->phSh.yFIR1 =  LL_fir_ll(tmp32_1,p->phSh.xFIR1,p->hilb.cofFIR1,p->hilb.lenFIR1);
		p->phSh.yFIR2 = -L_fir_ls (tmp32_2,p->phSh.xFIR2,p->hilb.cofFIR2,p->hilb.lenFIR2);
		/* reactive energy calculation and pulse state output                       */
		//CalcEnergy (&p->VARh[index], tmp32_1, tmp32_2, pCnt+index, outRes[index]);  	
		CalcEnergy (&p->VARh[index], L_extract_hi(p->phSh.yFIR1), p->phSh.yFIR2, pCnt+index, 
                     outRes[index]);
	}
  return 0;
}
/*************************************************************************//*!
 *
 * @brief   Recalculate auxiliary variables; IRMS, URMS, P, Q and S.
 *
 * @param   p       Pointer to metering library data structure (tMETERLIB1PH_DATA).
 *
 * @remarks Implemented in C-language. Note that this function must be called
 *          at constant frequency. Typical calling frequency is several times 
 *          lower than calling frequency of the METERLIB1PH_CalcWattHours function. 
 *          The frequency of this function calls must be used for calculation all 
 *          IIR low pass filter parameters. Function disables and enables 
 *          interrupts during execution.
 *
 ****************************************************************************/
void SMARTHOME_CalcAuxiliary (tSMARTHOME_DATA *p)
{   
	int index;
	register Frac32 tmp32_1, tmp32_2;
	register Frac64 tmp64_1;
	register unsigned int mask;
	Frac32 i[NUM_CHAN];
	//----------------------------------------------------------------------------
	/* disable interrupt and load variables                                     */
	mask = GetInterruptMask(); 
	__asm volatile ("CPSID i"); /* disable interrupts to keep data consistancy  */
	for (index=0;index<NUM_CHAN;index++)
	{
		index[i] = p->iDcb[index][1].yIIR>>24;
	}
	tmp32_2=p->uDcb[1].yIIR>>24;
	SetInterruptMask (mask);    /* re-enable interrupts                         */
	for (index=0;index<NUM_CHAN;index++)
	{
		/* Active power calculation                                             */
		tmp32_1=i[index];
		tmp64_1 = LL_mul_ll(tmp32_1,tmp32_2);
		tmp64_1 = LL_add(LL_iir_1ord (tmp64_1,&p->PAve[index].xIIR1,&p->PAve[index].yIIR1,p->aver.cofIIR1),
                   (p->Wh[index].offset<<16)); 
		LL_iir_1ord_ll(L_extract_hi(tmp64_1),&p->PAve[index].xIIR2,&p->PAve[index].yIIR2,p->aver.cofIIR2);
		
	}

	/* Voltage RMS calculation - direct RMS converter                           */
	tmp64_1 = LL_mul_ll   (tmp32_2,tmp32_2);
	tmp64_1 = LL_iir_1ord (tmp64_1,&p->uRms.xIIR1,&p->uRms.yIIR1,p->aver.cofIIR1);
	LL_iir_1ord_ll(L_sqr_ll(tmp64_1),&p->uRms.xIIR2,&p->uRms.yIIR2,p->aver.cofIIR2); 
	
	for (index=0;index<NUM_CHAN;index++)
	{
		/* Current RMS calculation - direct RMS converter                         */
		tmp32_1=i[index];
		tmp64_1 = LL_mul_ll   (tmp32_1,tmp32_1);
		tmp64_1 = LL_iir_1ord (tmp64_1,&p->iRms[index].xIIR1,&p->iRms[index].yIIR1,p->aver.cofIIR1);         
		LL_iir_1ord_ll(L_sqr_ll(tmp64_1),&p->iRms[index].xIIR2,&p->iRms[index].yIIR2,p->aver.cofIIR2);
	}
}

/*************************************************************************//*
 * @brief   Returns auxiliary variables: IRMS, URMS, P, Q and S.
 *
 * @param   p         Pointer to metering library data structure (tMETERLIB1PH_DATA).
 * @param   urms      Pointer to RMS value of phase voltage [U]
 * @param   irms      Pointer to RMS value of phase current calculated using Explicit 
 *                    RMS Estimator algorithm [A]
 * @param   w         Pointer to active power [W]
 * @param   var       Pointer to reactive power [VAr]
 * @param   va        Pointer to apparent power [VA]
 * @param   umax      Pointer to phase voltage circuit scaling (maximal peak voltage) [V]
 * @param   imax      Pointer to phase current circuit scaling (maximal peak current) [I]
 *
 * @remarks Implemented in C-language. Function disables interrupts prior 
 *          execution. Interrupts are re-enabled after function execution.
 *
 ****************************************************************************/
void SMARTHOME_ReadResults (tSMARTHOME_DATA *p, tSMARTHOME_RESULT *r, double *umax,double *imax)
{ 
	int index;
	register Frac32 tmp_1, tmp_2, tmp_3;
	register unsigned int mask;
	Frac32 i[NUM_CHAN],phase[NUM_CHAN];
	Frac32 tmp;
	/* disable interrupt and load variables                                     */
	mask = GetInterruptMask();
	__asm volatile ("CPSID i"); /* disable interrupts to keep data consistancy  */
	tmp_1 = L_extract_hi(p->uRms.yIIR2);
	for (index=0;index<NUM_CHAN;index++)
	{
		i[index] = L_extract_hi(p->iRms[index].yIIR2);
		phase[index] = L_extract_hi(p->PAve[index].yIIR2);
	}
  
	SetInterruptMask (mask);    /* re-enable interrupts                         */  

	r->urms = F32TODBL(tmp_1)*p->umax;  
	*umax = p->umax;
	*imax = p->imax[0];
	//----------------------------------------------------------------------------
	for (index=0;index<NUM_CHAN;index++)
	{

		tmp_2 = i[index];
		tmp_3 = phase[index];
		/* sensitivity threshold logic - clears powers and RMS current if values    */
		/* are below sensitivity threshold                                          */
		if(r->urms >= 50)
		{
			if ((tmp_3 < p->thrd) && (tmp_3 > -p->thrd)) { tmp_3 = 0l; }
			if (tmp_3 == 0l ) { tmp_2 = 0l; }
		}

		/* convert fractional quantities to double precision format                 */
		r->irms[index]= F32TODBL(tmp_2)*p->imax[index];

		
		r->p[index]    = F32TODBL(tmp_3)*(p->umax)*(p->imax[index]);
		r->q[index] = r->urms * r->irms[index];
		//if (r->w0 < 0) r->w0 = 0;
	}
}
